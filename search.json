[
  {
    "objectID": "pages/tags.html",
    "href": "pages/tags.html",
    "title": "PHS Package Development Guidance",
    "section": "",
    "text": "A tag is a git concept that allows you to label and attach information to a commit. For versioning, tags should be named according to the major/minor/patch format, prefixed by ‘v’, e.g. v1.1.0 and should match up with the version set in the package’s DESCRIPTION file on that commit.\nThere are two types of git tags: lightweight and annotated. A lightweight tag can be thought of as a branch that does not change and is simply a pointer to a specific commit. Annotated tags are stored as full objects in the Git database meaning they get checksummed and contain details such as the tagger name, email, date and a tagging message. Although annotated tags are generally recommended over lightweight tags, lightweight tags should be sufficient for the versioning process when developing PHS R packages.\nReleases are a GitHub concept, described by GitHub as “first-class objects with changelogs and binary assets that present a full project history beyond Git artefacts.” Compared to tags, releases include release notes and links to download the software or source code from GitHub. A release can be created from an existing tag, or a new tag will be created with the new release.\nIf you prefer working in the terminal with git, then only tags are required. If you prefer working with a GUI GitHub releases will be used (which will also create corresponding git tags).\n\n\nTo see a list of tags currently being used, you can run git tag. For phstemplates, we see the following tags (as at 26th June 2024).\n$ git tag\nv1.0.0\nv1.1.0\nv1.2.0\nv1.2.1\nTo see details from a particular tag and the associated commit, you can use the git show command.\n$ git show v1.2.1\ncommit 86878078431e4782697d808bb7e64b89b11de0d8 (tag: v1.2.1)\nAuthor: Alan Y &lt;34042624+alan-y@users.noreply.github.com&gt;\nDate:   Fri Jun 14 16:39:12 2024 +0100\nTo create a lightweight tag, we simply add the name you want to give the tag after the git tag command. For instance, git tag v1.2.2.\nFor an annotated tag, the -a option must be specified in git tag and the -m option can be used to set the tagging message. For example git tag -a v1.2.2 -m \"my version 1.2.2\". Note that if you do not include -m, a text editor will open up and you can enter the message anyway.\nThe key thing to remember with tags is that by default, git push does not transfer tags to Github. Tags have to be pushed separately after they have been created – for example, by typing git push origin v1.2.2.\nA useful feature is that commits can be tagged retrospectively using the shortened SHA (secure hash algorithm) associated with a commit. For example, to tag commit 8687807 in phstemplates with v1.2.1, we would use\n$ git tag v1.2.1 8687807\n$ git push origin v1.2.1\n\n\n\nFind the releases page for the repository, this can usually be seen in the column on the right of the page. For phstemplates the link would be https://github.com/Public-Health-Scotland/phstemplates/releases but generally it is ‘https://github.com/Public-Health-Scotland//releases’. Click the ‘Draft a new release’ button.\n\nFirst, click on ‘Choose a tag’ and either pick an existing tag or type the name for the new tag, following the guidance for naming above. To avoid confusion, it should match the package version in the DESCRIPTION file and be an increase from all previous tags. The target branch will usually be main (i.e. the latest commit to main) but you can target any branch or commit if needed. Now click ‘Generate release notes’ which will auto-populate the Release notes section with Markdown content summarising all the commits made between this and the most recent tag. You can now choose to save the draft, or more likely you can click ‘Publish release’ which will create the git tag and GitHub release."
  },
  {
    "objectID": "pages/tags.html#git-tags-and-releases",
    "href": "pages/tags.html#git-tags-and-releases",
    "title": "PHS Package Development Guidance",
    "section": "",
    "text": "A tag is a git concept that allows you to label and attach information to a commit. For versioning, tags should be named according to the major/minor/patch format, prefixed by ‘v’, e.g. v1.1.0 and should match up with the version set in the package’s DESCRIPTION file on that commit.\nThere are two types of git tags: lightweight and annotated. A lightweight tag can be thought of as a branch that does not change and is simply a pointer to a specific commit. Annotated tags are stored as full objects in the Git database meaning they get checksummed and contain details such as the tagger name, email, date and a tagging message. Although annotated tags are generally recommended over lightweight tags, lightweight tags should be sufficient for the versioning process when developing PHS R packages.\nReleases are a GitHub concept, described by GitHub as “first-class objects with changelogs and binary assets that present a full project history beyond Git artefacts.” Compared to tags, releases include release notes and links to download the software or source code from GitHub. A release can be created from an existing tag, or a new tag will be created with the new release.\nIf you prefer working in the terminal with git, then only tags are required. If you prefer working with a GUI GitHub releases will be used (which will also create corresponding git tags).\n\n\nTo see a list of tags currently being used, you can run git tag. For phstemplates, we see the following tags (as at 26th June 2024).\n$ git tag\nv1.0.0\nv1.1.0\nv1.2.0\nv1.2.1\nTo see details from a particular tag and the associated commit, you can use the git show command.\n$ git show v1.2.1\ncommit 86878078431e4782697d808bb7e64b89b11de0d8 (tag: v1.2.1)\nAuthor: Alan Y &lt;34042624+alan-y@users.noreply.github.com&gt;\nDate:   Fri Jun 14 16:39:12 2024 +0100\nTo create a lightweight tag, we simply add the name you want to give the tag after the git tag command. For instance, git tag v1.2.2.\nFor an annotated tag, the -a option must be specified in git tag and the -m option can be used to set the tagging message. For example git tag -a v1.2.2 -m \"my version 1.2.2\". Note that if you do not include -m, a text editor will open up and you can enter the message anyway.\nThe key thing to remember with tags is that by default, git push does not transfer tags to Github. Tags have to be pushed separately after they have been created – for example, by typing git push origin v1.2.2.\nA useful feature is that commits can be tagged retrospectively using the shortened SHA (secure hash algorithm) associated with a commit. For example, to tag commit 8687807 in phstemplates with v1.2.1, we would use\n$ git tag v1.2.1 8687807\n$ git push origin v1.2.1\n\n\n\nFind the releases page for the repository, this can usually be seen in the column on the right of the page. For phstemplates the link would be https://github.com/Public-Health-Scotland/phstemplates/releases but generally it is ‘https://github.com/Public-Health-Scotland//releases’. Click the ‘Draft a new release’ button.\n\nFirst, click on ‘Choose a tag’ and either pick an existing tag or type the name for the new tag, following the guidance for naming above. To avoid confusion, it should match the package version in the DESCRIPTION file and be an increase from all previous tags. The target branch will usually be main (i.e. the latest commit to main) but you can target any branch or commit if needed. Now click ‘Generate release notes’ which will auto-populate the Release notes section with Markdown content summarising all the commits made between this and the most recent tag. You can now choose to save the draft, or more likely you can click ‘Publish release’ which will create the git tag and GitHub release."
  },
  {
    "objectID": "pages/tags.html#further-reading",
    "href": "pages/tags.html#further-reading",
    "title": "PHS Package Development Guidance",
    "section": "Further Reading",
    "text": "Further Reading\n\nGit - Tagging\n\nManaging releases in a repository - GitHub Docs\n\nIs there a standard naming convention for git tags?\n\nWhat’s the difference between tag and release?"
  },
  {
    "objectID": "pages/r-package-versioning.html",
    "href": "pages/r-package-versioning.html",
    "title": "PHS Package Development Guidance",
    "section": "",
    "text": "For PHS R packages, we recommend that package maintainers handle all versioning, following the tidyverse approach to versioning:\n\nUse the . separator rather than -.\nVersion number should always include the major, minor and patch number, e.g. 1.4.0.\nIncrement the major, the minor or patch number reflecting the changes made in the release. Taking the 1.4.0 example above, a patch release would increment to 1.4.1, a minor release to 1.5.0, a major release to 2.0.0\n\nThe version is set in the package’s DESCRIPTION file. This can be edited directly or by using the function usethis::use_version(). Some examples of what types of changes would be considered in each of the types of releases:\nPatch release: No breaking changes and no significant new features. For example, backward-compatible bug fixes, addition of new unit tests, minor changes to documentation or vignettes and minor changes to a template.\nMinor release: New features / functionality or improvements introduced; all changes are backward compatible. Examples could include adding new arguments to functions (that remain backwards compatible), introducing new functions (that are not critical to the overall functionality of the package), and efficiency improvements (these may also be considered for a patch release, depending on how important those efficiency improvements are).\nMajor release: Breaking changes (changes that are not backwards compatible), changes likely to impact many users. Significant new features or functions you want to highlight.\nSome questions to ask when deciding how to increment the version number for a new release include:\n\nAre there any breaking changes? If the answer is yes, this should be a major release. (You should also consider using lifecycle to manage and communicate these breaking changes).\nAre there any changes to functionality (that are user-facing)? If the answer is yes, the release should be minor or major.\n\nNote that it may not always be necessary to increment the version. For example, if only minor typos were fixed in documentation or if the changes were trivial or non-user-facing, it may not be worth changing the version. The guidelines for versioning should be followed as far as possible but it is up to package maintainers to consider how and when to increment versions."
  },
  {
    "objectID": "pages/r-package-versioning.html#r-package-versioning",
    "href": "pages/r-package-versioning.html#r-package-versioning",
    "title": "PHS Package Development Guidance",
    "section": "",
    "text": "For PHS R packages, we recommend that package maintainers handle all versioning, following the tidyverse approach to versioning:\n\nUse the . separator rather than -.\nVersion number should always include the major, minor and patch number, e.g. 1.4.0.\nIncrement the major, the minor or patch number reflecting the changes made in the release. Taking the 1.4.0 example above, a patch release would increment to 1.4.1, a minor release to 1.5.0, a major release to 2.0.0\n\nThe version is set in the package’s DESCRIPTION file. This can be edited directly or by using the function usethis::use_version(). Some examples of what types of changes would be considered in each of the types of releases:\nPatch release: No breaking changes and no significant new features. For example, backward-compatible bug fixes, addition of new unit tests, minor changes to documentation or vignettes and minor changes to a template.\nMinor release: New features / functionality or improvements introduced; all changes are backward compatible. Examples could include adding new arguments to functions (that remain backwards compatible), introducing new functions (that are not critical to the overall functionality of the package), and efficiency improvements (these may also be considered for a patch release, depending on how important those efficiency improvements are).\nMajor release: Breaking changes (changes that are not backwards compatible), changes likely to impact many users. Significant new features or functions you want to highlight.\nSome questions to ask when deciding how to increment the version number for a new release include:\n\nAre there any breaking changes? If the answer is yes, this should be a major release. (You should also consider using lifecycle to manage and communicate these breaking changes).\nAre there any changes to functionality (that are user-facing)? If the answer is yes, the release should be minor or major.\n\nNote that it may not always be necessary to increment the version. For example, if only minor typos were fixed in documentation or if the changes were trivial or non-user-facing, it may not be worth changing the version. The guidelines for versioning should be followed as far as possible but it is up to package maintainers to consider how and when to increment versions."
  },
  {
    "objectID": "pages/r-package-versioning.html#in-development-versions",
    "href": "pages/r-package-versioning.html#in-development-versions",
    "title": "PHS Package Development Guidance",
    "section": "In-development Versions",
    "text": "In-development Versions\nDuring the initial development of a package, the package version can include a fourth number starting at: 0.0.0.9000. During this stage the package is not considered stable, things are expected to change at any point, which is why it is important for the version number to clearly signal that the package is in this development stage. The development version number may be incremented (e.g. 0.0.0.9000 to 0.0.0.9001) if there is a need to differentiate versions of the development version, although this is typically not necessary with every commit.\nOne advantage of using the fourth number like this for a development version is that it leaves all version options open for the next released version, i.e. it can be any of 0.0.1, 0.1.0 or 1.0.0. Note that the version 1.0.0 is generally used to communicate that the package is considered stable."
  },
  {
    "objectID": "pages/r-package-versioning.html#further-reading",
    "href": "pages/r-package-versioning.html#further-reading",
    "title": "PHS Package Development Guidance",
    "section": "Further Reading",
    "text": "Further Reading\n\nR Packages - Lifecycle\n\nSemantic Versioning\n\nX.Org Version Numbering Schemes\n\nManaging Releases with Semantic Versioning and Git Tags\n\nR Packages - DESCRIPTION"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Guidance for developing PHS R Packages",
    "section": "",
    "text": "This is a short guide to versioning and tagging when developing R packages in Public Health Scotland (PHS) that are hosted on GitHub. The aim is to have a consistent process that can be followed for those developing PHS R packages."
  },
  {
    "objectID": "index.html#why-do-we-need-this-guidance",
    "href": "index.html#why-do-we-need-this-guidance",
    "title": "Guidance for developing PHS R Packages",
    "section": "Why do we need this guidance?",
    "text": "Why do we need this guidance?\nPHS is using Posit Package Manager to host R packages (including PHS R packages) internally and this allows users of Posit Workbench to install packages securely and simply using install.packages(). Versioning and tagging have implications for Posit Package Manager, depending on how it has been set up for hosting PHS R packages which are being developed on GitHub. The desired result of developing packages according to this guidance is that users always have access to the latest stable release and are not missing out on any important developments when they install PHS R packages."
  },
  {
    "objectID": "index.html#who-is-this-guidance-for",
    "href": "index.html#who-is-this-guidance-for",
    "title": "Guidance for developing PHS R Packages",
    "section": "Who is this guidance for?",
    "text": "Who is this guidance for?\nThis guidance is for developers and maintainers of PHS R packages. It is also for those interested in developing PHS R packages or those who want to learn to do this. It is assumed that the reader has some pre-existing knowledge regarding Git and developing R packages."
  },
  {
    "objectID": "index.html#what-this-guidance-does-not-cover",
    "href": "index.html#what-this-guidance-does-not-cover",
    "title": "Guidance for developing PHS R Packages",
    "section": "What this guidance does not cover",
    "text": "What this guidance does not cover\nThis guidance only discusses particular aspects of R package development and Git and is not a general guide to either of these.\nFor a comprehensive guide to developing R packages, please see the R Packages book.\nTo learn more about Git, please see, for example, the Pro Git book, Happy Git and GitHub for the useR or git - the simple guide."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "This website aims to provide guidance on best practice for setting up and developing packages within Public Health Scotland.\nThe website was developed in Quarto and has the following contributors (in alphabetical order):\n\nNick Christofides\nJon Minton\nCsilla Scharle\nAlan Yeung\n\nThe repository containing the code for the website is publically available on github here. You can contribute by either raising an issue, or forking the repo and making a pull request."
  },
  {
    "objectID": "pages/package-manager.html",
    "href": "pages/package-manager.html",
    "title": "PHS Package Development Guidance",
    "section": "",
    "text": "PHS have an instance of Posit Package Manager, - ppm.publichealthscotland.org - this provides a seamless interface for internal PHS users when installing packages either from CRAN, or packages hosted elsewhere - this is how the PHS packages can be installed easily even though they are only hosted on GitHub.\nThere are two ways for the PHS Posit Package Manager to manage versions for R packages on GitHub (not applicable to CRAN packages): tags or commits. Commits mode is the default and based on all commits made to a Git branch (usually main / master), while tags mode is based on Git tags in the package repository.\n\nCommits: The package gets updated on Posit Package Manager each time a new commit is made to the specified branch. The package version is updated automatically with the commit timestamp reflected at the end of the version number. This guarantees the version number for each new commit will be higher than the previous version number. E.g. phsstyles is on version 0.1.1, however, the version number created by Posit Package Manager is 0.1.1.0.0.0.1654859281.\nTags: The package gets updated on Posit Package Manager each time a Git tag is used in the repository. The package version is defined in the package’s DESCRIPTION file, corresponding to the name of the tag. If two tags reference the same version, preference is given to the newer tag. If a newer tag references an older version than a prior tag, the new tag is built as an archived package. If a tag is removed from a Git endpoint, any packages already built for that tag remain.\n\nCommit mode is simpler and requires less work from package maintainers, but it is not recommended. Tag mode is more suitable as it will only expose package releases to users when the maintainer decides to."
  },
  {
    "objectID": "pages/package-manager.html#posit-package-manager",
    "href": "pages/package-manager.html#posit-package-manager",
    "title": "PHS Package Development Guidance",
    "section": "",
    "text": "PHS have an instance of Posit Package Manager, - ppm.publichealthscotland.org - this provides a seamless interface for internal PHS users when installing packages either from CRAN, or packages hosted elsewhere - this is how the PHS packages can be installed easily even though they are only hosted on GitHub.\nThere are two ways for the PHS Posit Package Manager to manage versions for R packages on GitHub (not applicable to CRAN packages): tags or commits. Commits mode is the default and based on all commits made to a Git branch (usually main / master), while tags mode is based on Git tags in the package repository.\n\nCommits: The package gets updated on Posit Package Manager each time a new commit is made to the specified branch. The package version is updated automatically with the commit timestamp reflected at the end of the version number. This guarantees the version number for each new commit will be higher than the previous version number. E.g. phsstyles is on version 0.1.1, however, the version number created by Posit Package Manager is 0.1.1.0.0.0.1654859281.\nTags: The package gets updated on Posit Package Manager each time a Git tag is used in the repository. The package version is defined in the package’s DESCRIPTION file, corresponding to the name of the tag. If two tags reference the same version, preference is given to the newer tag. If a newer tag references an older version than a prior tag, the new tag is built as an archived package. If a tag is removed from a Git endpoint, any packages already built for that tag remain.\n\nCommit mode is simpler and requires less work from package maintainers, but it is not recommended. Tag mode is more suitable as it will only expose package releases to users when the maintainer decides to."
  },
  {
    "objectID": "pages/package-manager.html#package-manager-in-phs",
    "href": "pages/package-manager.html#package-manager-in-phs",
    "title": "PHS Package Development Guidance",
    "section": "Package Manager in PHS",
    "text": "Package Manager in PHS\nYou can check if the PHS Posit Package Manager is using tags or commits for a particular package by searching the package name at https://ppm.publichealthscotland.org/client/#/repos/3/packages (the link can only be accessed when you are connected to the PHS network).\nIf we look at phsstyles on Package Manager, we can see it is using commit mode (as of 27th June 2024) as the version number is long and looks auto-generated (0.1.1.0.0.0.1654859281)."
  },
  {
    "objectID": "pages/package-manager.html#advantages-and-disadvantages",
    "href": "pages/package-manager.html#advantages-and-disadvantages",
    "title": "PHS Package Development Guidance",
    "section": "Advantages and Disadvantages",
    "text": "Advantages and Disadvantages\nUsing commit mode on Package Manager to host an R package makes it easier for maintainers as they do not have to worry about package versions with every update. The package maintainers would have to ensure (as far as possible) that only stable commits are made on the main branch. However, the disadvantage is that version history may be long (particularly if several small commits have been made) and storage space on the infrastructure used to host Package Manager is needed to store all source files. For example, phstemplates on Package Manager has a version created for every commit to the main branch:\nVERSION\n1.2.1.0.0.0.1719407970\n\nARCHIVED VERSIONS\n1.2.1.0.0.0.1718379552\nJun 14, 2024 3:39 PM UTC\n1.2.0.0.0.0.1707843561\nFeb 13, 2024 4:59 PM UTC\n1.1.1.0.0.0.1705940511\nJan 22, 2024 4:21 PM UTC\n1.1.1.0.0.0.1704882475\nJan 10, 2024 10:27 AM UTC\n1.1.1.0.0.0.1700760626\nNov 23, 2023 5:30 PM UTC\n1.1.1.0.0.0.1700647485\nNov 22, 2023 10:04 AM UTC\n1.1.1.0.0.0.1699616873\nNov 10, 2023 11:47 AM UTC\n1.1.1.0.0.0.1699351034\nNov 7, 2023 9:57 AM UTC\n1.1.1.0.0.0.1698952735\nNov 2, 2023 7:18 PM UTC\n1.1.1.0.0.0.1698157806\nOct 24, 2023 2:30 PM UTC\n1.1.1.0.0.0.1698053868\nOct 23, 2023 9:37 AM UTC\n1.1.1.0.0.0.1696581278\nOct 6, 2023 8:34 AM UTC\n1.1.1.0.0.0.1696322496\nOct 3, 2023 8:41 AM UTC\n1.1.1.0.0.0.1696251514\nOct 2, 2023 12:58 PM UTC\n1.1.0.0.0.0.1695820271\nSep 27, 2023 1:11 PM UTC\n1.1.0.0.0.0.1695805326\nSep 27, 2023 9:02 AM UTC\n1.1.0.0.0.0.1695735559\nSep 26, 2023 1:39 PM UTC\n1.1.0.0.0.0.1695658190\nSep 25, 2023 4:09 PM UTC\n1.1.0.0.0.0.1695206490\nSep 20, 2023 10:41 AM UTC\n1.1.0.0.0.0.1689262223\nJul 13, 2023 3:30 PM UTC\n1.1.0.0.0.0.1661965078\nAug 31, 2022 4:57 PM UTC\nAnother drawback with commit mode is that you would have to look at the commit history on GitHub to see exactly what changes were made for each of these versions. If a major bug was introduced at some point in the commit history, it could be challenging for a user to find and install the most recent stable version. Similarly, if a user has an issue with the package, identifying exactly which version of the package / code they have installed can be a hurdle.\nTags mode requires more administrative work by maintainers of R packages (as an extra step is needed to associate commits with tags and to push these tags to GitHub) but should result in a cleaner version history on the Package Manager. The deliberate tagging process should mean we get only a list of stable releases and changes in each version should have been documented in NEWS.md.\nIf Package Manager were to use tags mode for phstemplates, we would have only the latest v1.2.1 and three previous archived versions available, resulting in a lot fewer archived versions compared with commits mode.\n$ git tag\nv1.0.0\nv1.1.0\nv1.2.0\nv1.2.1\nThe benefit for users would be that it would be easier to install previous versions of a package if needed (for example, if the latest version introduced a bug). There should also be fewer versions created on Package Manager which would save some storage space on the infrastructure. Furthermore, these tags can be reviewed periodically and redundant versions can be deleted if desired."
  },
  {
    "objectID": "pages/package-manager.html#adding-a-package-to-the-package-manager",
    "href": "pages/package-manager.html#adding-a-package-to-the-package-manager",
    "title": "PHS Package Development Guidance",
    "section": "Adding a package to the Package Manager",
    "text": "Adding a package to the Package Manager\nThe Package Manager is administered by the Data Science team, so an email to them will be required to have a package (a GitHub or Gitea repository) added. To have a package changed from commit mode (the default) to tag mode (recommended) you will similarly need to contact the Data Science team."
  },
  {
    "objectID": "pages/package-manager.html#further-reading",
    "href": "pages/package-manager.html#further-reading",
    "title": "PHS Package Development Guidance",
    "section": "Further Reading",
    "text": "Further Reading\nBuilding Git Packages - Posit Package Manager"
  },
  {
    "objectID": "pages/recommended-git-workflow.html",
    "href": "pages/recommended-git-workflow.html",
    "title": "PHS Package Development Guidance",
    "section": "",
    "text": "Our recommended Git/Github developer workflow for versioning and tagging is as follows:\n\nCreate a development branch and switch to it, e.g.  git checkout -b feature/cool_new_feature\nAdd your developments, commit and push these changes.\n\ngit add -A  \ngit commit -m \"Add &lt;foo&gt; so it can do &lt;bar&gt;\"\ngit push origin feature/cool_new_feature\n\nSubmit a Pull Request (PR) on GitHub and go through the review process.\nOnce changes are approved, the maintainer decides on the major/minor/patch version increment (e.g. 1.3.0)\nThe developer updates to the agreed version in DESCRIPTION and updates NEWS.md, e.g.\nusethis::use_version(which = \"minor\", push = TRUE)\n\nThe pull request is merged to the main branch\nThe commit (let’s say the SHA is 1234567) is tagged with v1.3.0\ngit tag 1234567 v1.3.0\ngit push origin v1.3.0\n\nGraphically, this looks as follows:\n\n\n\n\nflowchart TB\n    mb([\"Main Branch\"])\n    cdb[\"Development Branch\"]\n    ca[\"Changes added\\nChanges committed\\nChanges pushed\"]\n    cr{Code Review}\n    vi[Version incremented]\n    ta[Tag latest commit]\n    mbu([Main Branch updated])\n\n    mb --\"git checkout -b feature/cool_new_feature\" --&gt; cdb\n    cdb --\"git add -A\\ngit commit -m 'Add &lt;foo&gt; so it can do &lt;bar&gt;'\\ngit push origin feature/cool_new_feature\" --&gt; ca\n    ca --\"Github: Make Pull Request\"--&gt; cr\n    cr --\"Accept changes\\nusethis::use_version(which = 'minor', push = TRUE)\\nUpdate NEWS.md\"--&gt; vi\n    vi -- \"Pull request merged to main\" --&gt; mbu\n    cr --\"Reject changes\"--&gt; cdb\n    ta &lt;-.\"git tag 1234567 v1.3.0\\ngit push origin v1.3.0\".-&gt; mbu\n\n    linkStyle default stroke:lightgray \n\n\n\n\n\nNote that this assumes that a single change would warrant a package version increment. If changes are smaller they can instead be merged into a separate branch e.g. development, when there are enough small changes, or there is also a bigger change, this development ‘holding’ branch can be merged into main following the steps from number 4."
  },
  {
    "objectID": "pages/recommended-git-workflow.html#recommended-git-workflow",
    "href": "pages/recommended-git-workflow.html#recommended-git-workflow",
    "title": "PHS Package Development Guidance",
    "section": "",
    "text": "Our recommended Git/Github developer workflow for versioning and tagging is as follows:\n\nCreate a development branch and switch to it, e.g.  git checkout -b feature/cool_new_feature\nAdd your developments, commit and push these changes.\n\ngit add -A  \ngit commit -m \"Add &lt;foo&gt; so it can do &lt;bar&gt;\"\ngit push origin feature/cool_new_feature\n\nSubmit a Pull Request (PR) on GitHub and go through the review process.\nOnce changes are approved, the maintainer decides on the major/minor/patch version increment (e.g. 1.3.0)\nThe developer updates to the agreed version in DESCRIPTION and updates NEWS.md, e.g.\nusethis::use_version(which = \"minor\", push = TRUE)\n\nThe pull request is merged to the main branch\nThe commit (let’s say the SHA is 1234567) is tagged with v1.3.0\ngit tag 1234567 v1.3.0\ngit push origin v1.3.0\n\nGraphically, this looks as follows:\n\n\n\n\nflowchart TB\n    mb([\"Main Branch\"])\n    cdb[\"Development Branch\"]\n    ca[\"Changes added\\nChanges committed\\nChanges pushed\"]\n    cr{Code Review}\n    vi[Version incremented]\n    ta[Tag latest commit]\n    mbu([Main Branch updated])\n\n    mb --\"git checkout -b feature/cool_new_feature\" --&gt; cdb\n    cdb --\"git add -A\\ngit commit -m 'Add &lt;foo&gt; so it can do &lt;bar&gt;'\\ngit push origin feature/cool_new_feature\" --&gt; ca\n    ca --\"Github: Make Pull Request\"--&gt; cr\n    cr --\"Accept changes\\nusethis::use_version(which = 'minor', push = TRUE)\\nUpdate NEWS.md\"--&gt; vi\n    vi -- \"Pull request merged to main\" --&gt; mbu\n    cr --\"Reject changes\"--&gt; cdb\n    ta &lt;-.\"git tag 1234567 v1.3.0\\ngit push origin v1.3.0\".-&gt; mbu\n\n    linkStyle default stroke:lightgray \n\n\n\n\n\nNote that this assumes that a single change would warrant a package version increment. If changes are smaller they can instead be merged into a separate branch e.g. development, when there are enough small changes, or there is also a bigger change, this development ‘holding’ branch can be merged into main following the steps from number 4."
  }
]