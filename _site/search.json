[
  {
    "objectID": "pages/tags.html",
    "href": "pages/tags.html",
    "title": "PHS Package Development Guidance",
    "section": "",
    "text": "A tag is a git concept that allows you to label and attach information to a commit. For versioning, tags should be named according to the major/minor/patch format, prefixed by ‘v’, e.g. v1.1.0 and should match up with the version set in the package’s DESCRIPTION file on that commit. There are two types of git tags: lightweight and annotated.\nA lightweight tag can be thought of as a branch that does not change and is simply a pointer to a specific commit.\nAnnotated tags are more complicated. They are stored as full objects in the Git database meaning they get checksummed and contain details such as the tagger name, email, date and a tagging message.\nAlthough annotated tags include all this information (and are generally recommended over lightweight tags), lightweight tags should be sufficient for the versioning process when developing PHS R packages.\nReleases are a Github higher level concept, described by GitHub as “first-class objects with changelogs and binary assets that present a full project history beyond Git artifacts.” Compared to tags, releases include release notes and links to download the software or source code from GitHub. A release can be created from an existing tag, alternatively an associated tag will be created along with the new release.\nIn order of complexity, we would have lightweight tags being simplest, followed by annotated tags, and lastly releases."
  },
  {
    "objectID": "pages/tags.html#git-tags-and-releases",
    "href": "pages/tags.html#git-tags-and-releases",
    "title": "PHS Package Development Guidance",
    "section": "",
    "text": "A tag is a git concept that allows you to label and attach information to a commit. For versioning, tags should be named according to the major/minor/patch format, prefixed by ‘v’, e.g. v1.1.0 and should match up with the version set in the package’s DESCRIPTION file on that commit. There are two types of git tags: lightweight and annotated.\nA lightweight tag can be thought of as a branch that does not change and is simply a pointer to a specific commit.\nAnnotated tags are more complicated. They are stored as full objects in the Git database meaning they get checksummed and contain details such as the tagger name, email, date and a tagging message.\nAlthough annotated tags include all this information (and are generally recommended over lightweight tags), lightweight tags should be sufficient for the versioning process when developing PHS R packages.\nReleases are a Github higher level concept, described by GitHub as “first-class objects with changelogs and binary assets that present a full project history beyond Git artifacts.” Compared to tags, releases include release notes and links to download the software or source code from GitHub. A release can be created from an existing tag, alternatively an associated tag will be created along with the new release.\nIn order of complexity, we would have lightweight tags being simplest, followed by annotated tags, and lastly releases."
  },
  {
    "objectID": "pages/tags.html#creating-and-pushing-tags",
    "href": "pages/tags.html#creating-and-pushing-tags",
    "title": "PHS Package Development Guidance",
    "section": "Creating and Pushing Tags",
    "text": "Creating and Pushing Tags\nTo see a list of tags currently being used, you can run git tag. For phstemplates, we see the following tags (as at 26th June 2024).\n$ git tag\nv1.0.0\nv1.1.0\nv1.2.0\nv1.2.1\nTo see details from a particular tag and the associated commit, you can use the git show command.\n$ git show v1.2.1\ncommit 86878078431e4782697d808bb7e64b89b11de0d8 (tag: v1.2.1)\nAuthor: Alan Y &lt;34042624+alan-y@users.noreply.github.com&gt;\nDate:   Fri Jun 14 16:39:12 2024 +0100\nTo create a lightweight tag, we simply add on the name you want to give the tag after the git tag command. For instance, git tag v1.2.2.\nFor an annotated tag, the -a option must be specified in git tag and the -m option can be used to set the tagging message. For example git tag -a v1.2.2 -m \"my version 1.2.2\" . Note that if you do not include -m, a text editor will open up and you can enter the message anyway.\nThe key thing to remember with tags is that by default, git push does not transfer tags to Github. Tags have to be pushed separately after they have been created – for example, by typing git push origin v1.2.2.\nA useful feature is that commits can be tagged retrospectively using the shortened SHA (secure hash algorithm) associated with a commit. For example, to tag commit 8687807 in phstemplates with v1.2.1, we would use\n$ git tag v1.2.1 8687807\n$ git push origin v1.2.1"
  },
  {
    "objectID": "pages/tags.html#further-reading",
    "href": "pages/tags.html#further-reading",
    "title": "PHS Package Development Guidance",
    "section": "Further Reading",
    "text": "Further Reading\nGit - Tagging\nManaging releases in a repository - GitHub Docs\nIs there a standard naming convention for git tags?\nWhat’s the difference between tag and release?"
  },
  {
    "objectID": "pages/r-package-versioning.html",
    "href": "pages/r-package-versioning.html",
    "title": "PHS Package Development Guidance",
    "section": "",
    "text": "For PHS R packages, we recommend that package maintainers handle all versioning, following the tidyverse approach to versioning:\n\nUse the . separator rather than -.\nVersion number should always include the major, minor and patch number, e.g. 1.4.0.\nIncrement the major, the minor or patch number reflecting the changes made in the release. Taking the 1.4.0 example above, a patch release would increment to 1.4.1, a minor release to 1.5.0, a major release to 2.0.0\n\nThe version is set in the package’s DESCRIPTION file. This can be edited directly or by using the function usethis::use_version(). Some examples of what types of changes would be considered in each of the types of releases:\nPatch release: No breaking changes and no significant new features. For example, backward compatible bug fixes, addition of new unit tests, minor changes to documentation or vignettes and minor changes to a template.\nMinor release: New features / functionality or improvements introduced; all changes are backward compatible. Examples could include adding new arguments to functions (that remain backward compatible), introducing new functions (that are not critical to the overall functionality of the package), and efficiency improvements (these may also be considered for a patch release, depending on how important those efficiency improvements are).\nMajor release: Breaking changes (changes that are not backward compatible), changes likely to impact on many users. Significant new features or functions you want to highlight.\nSome questions to ask when deciding how to increment the version number for a new release include:\n\nAre there any breaking changes?\nIf the answer is yes, this should be a major release.\nAre there any changes to functionality (that are user-facing)?\nIf the answer is yes, the release should be minor or major.\n\nNote that it may not always be necessary to increment the version. For example, if only minor typos were fixed in documentation or if the changes were trivial, it may not be worth changing the version. The general guidelines for versioning should be followed as far as possible but it is inevitable that some personal judgement by the package maintainers needs to be exercised when considering how best to increment versions."
  },
  {
    "objectID": "pages/r-package-versioning.html#r-package-versioning",
    "href": "pages/r-package-versioning.html#r-package-versioning",
    "title": "PHS Package Development Guidance",
    "section": "",
    "text": "For PHS R packages, we recommend that package maintainers handle all versioning, following the tidyverse approach to versioning:\n\nUse the . separator rather than -.\nVersion number should always include the major, minor and patch number, e.g. 1.4.0.\nIncrement the major, the minor or patch number reflecting the changes made in the release. Taking the 1.4.0 example above, a patch release would increment to 1.4.1, a minor release to 1.5.0, a major release to 2.0.0\n\nThe version is set in the package’s DESCRIPTION file. This can be edited directly or by using the function usethis::use_version(). Some examples of what types of changes would be considered in each of the types of releases:\nPatch release: No breaking changes and no significant new features. For example, backward compatible bug fixes, addition of new unit tests, minor changes to documentation or vignettes and minor changes to a template.\nMinor release: New features / functionality or improvements introduced; all changes are backward compatible. Examples could include adding new arguments to functions (that remain backward compatible), introducing new functions (that are not critical to the overall functionality of the package), and efficiency improvements (these may also be considered for a patch release, depending on how important those efficiency improvements are).\nMajor release: Breaking changes (changes that are not backward compatible), changes likely to impact on many users. Significant new features or functions you want to highlight.\nSome questions to ask when deciding how to increment the version number for a new release include:\n\nAre there any breaking changes?\nIf the answer is yes, this should be a major release.\nAre there any changes to functionality (that are user-facing)?\nIf the answer is yes, the release should be minor or major.\n\nNote that it may not always be necessary to increment the version. For example, if only minor typos were fixed in documentation or if the changes were trivial, it may not be worth changing the version. The general guidelines for versioning should be followed as far as possible but it is inevitable that some personal judgement by the package maintainers needs to be exercised when considering how best to increment versions."
  },
  {
    "objectID": "pages/r-package-versioning.html#in-development-versions",
    "href": "pages/r-package-versioning.html#in-development-versions",
    "title": "PHS Package Development Guidance",
    "section": "In-development Versions",
    "text": "In-development Versions\nDuring the initial development of a package, the package version can include a fourth number starting at: 0.0.0.9000. During this stage the package is not considered stable, things are expected to change at any point, which is why it is important for the version number to clearly signal that the package is in this development stage. The development version number may be incremented (e.g. 0.0.0.9000 to 0.0.0.9001) if there is a need to differentiate versions of the development version, although this is typically not necessary with every commit.\nOne advantage of using the fourth number like this for a development version is that it leaves all version options open for the next released version, i.e. it can be any of 0.0.1, 0.1.0 or 1.0.0. Note that the version 1.0.0 is generally used to communicate that the package is considered stable."
  },
  {
    "objectID": "pages/r-package-versioning.html#further-reading",
    "href": "pages/r-package-versioning.html#further-reading",
    "title": "PHS Package Development Guidance",
    "section": "Further Reading",
    "text": "Further Reading\nR Packages - Lifecycle\nSemantic Versioning\nX.Org Version Numbering Schemes\nManaging Releases with Semantic Versioning and Git Tags\nR Packages - DESCRIPTION"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Guidance for developing PHS R Packages",
    "section": "",
    "text": "This is a short guide to versioning and tagging when developing R packages in Public Health Scotland (PHS) that are hosted on Github. The aim is to have to a consistent process that can be followed for those developing PHS R packages."
  },
  {
    "objectID": "index.html#why-do-we-need-this-guidance",
    "href": "index.html#why-do-we-need-this-guidance",
    "title": "Guidance for developing PHS R Packages",
    "section": "Why do we need this guidance?",
    "text": "Why do we need this guidance?\nPHS is using POSIT Package Manager to host R packages (including PHS R packages) internally and this allows users of POSIT Workbench to install packages securely and simply using install.packages(). Versioning and tagging have implications on POSIT Package Manager, depending on how it has been set up for hosting PHS R packages which are being developed on Github. The desired result of developing packages according to this guidance is that users always have access to the latest stable release and are not missing out on any important developments when they install PHS R packages."
  },
  {
    "objectID": "index.html#who-is-this-guidance-for",
    "href": "index.html#who-is-this-guidance-for",
    "title": "Guidance for developing PHS R Packages",
    "section": "Who is this guidance for?",
    "text": "Who is this guidance for?\nThis guidance is for developers and maintainers of PHS R packages. It is also for those interested in developing PHS R packages or those that want to learn to do this. It is assumed that the reader has some pre-existing knowledge regarding Git and developing R packages."
  },
  {
    "objectID": "index.html#what-this-guidance-does-not-cover",
    "href": "index.html#what-this-guidance-does-not-cover",
    "title": "Guidance for developing PHS R Packages",
    "section": "What this guidance does not cover",
    "text": "What this guidance does not cover\nThis guidance only discusses particular aspects of R package development and Git and is not a general guide to either of these.\nFor a comprehensive guide to developing R packages, please see the R Packages book.\nTo learn more about Git, please see, for example, the Pro Git book, Happy Git and GitHub for the useR or git - the simple guide."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "This website aims to provide guidance on best practice for setting up and developing packages within Public Health Scotland.\nThe website was developed in Quarto and has the following contributors (in alphabetical order):\n\nNick Christofides\nJon Minton\nCsilla Scharle\nAlan Yeung\n\nThe repository containing the code for the website is publically available on github here. You can contribute by either raising an issue, or forking the repo and making a pull request."
  },
  {
    "objectID": "pages/package-manager.html",
    "href": "pages/package-manager.html",
    "title": "PHS Package Development Guidance",
    "section": "",
    "text": "There are two ways for Posit Package Manager to pick up updates from R packages on Github (not applicable to CRAN packages): tags or commits. Commits mode is based on all commits made to a Git branch, while tags mode is based on Git tags in the package repository.\n\nCommits: The package gets updated on Posit Package Manager each time a new commit is made to the specified branch. The package version is updated automatically with the commit time-stamp reflected at the end of the version number. This guarantees the version number for each new commit will be higher than the previous version number. E.g. phsstyles is on version 0.1.1, however the version number created by Posit Package Manager is 0.1.1.0.0.0.1654859281.\nTags: The package gets updated on Posit Package Manager each time a Git tag is used in the repository. The package version is defined in the package’s DESCRIPTION file, corresponding to the name of the tag. If two tags reference the same version, preference is given to the newer tag. If a newer tag references an older version than a prior tag, the new tag is built as an archived package. If a tag is removed from a Git endpoint, any packages already built for that tag remain.\n\nCommit mode is recommended when you only want users to have access to every individual update/commit made in a package, whereas tag mode is more suitable when you only want to expose stable releases of packages to users."
  },
  {
    "objectID": "pages/package-manager.html#posit-package-manager",
    "href": "pages/package-manager.html#posit-package-manager",
    "title": "PHS Package Development Guidance",
    "section": "",
    "text": "There are two ways for Posit Package Manager to pick up updates from R packages on Github (not applicable to CRAN packages): tags or commits. Commits mode is based on all commits made to a Git branch, while tags mode is based on Git tags in the package repository.\n\nCommits: The package gets updated on Posit Package Manager each time a new commit is made to the specified branch. The package version is updated automatically with the commit time-stamp reflected at the end of the version number. This guarantees the version number for each new commit will be higher than the previous version number. E.g. phsstyles is on version 0.1.1, however the version number created by Posit Package Manager is 0.1.1.0.0.0.1654859281.\nTags: The package gets updated on Posit Package Manager each time a Git tag is used in the repository. The package version is defined in the package’s DESCRIPTION file, corresponding to the name of the tag. If two tags reference the same version, preference is given to the newer tag. If a newer tag references an older version than a prior tag, the new tag is built as an archived package. If a tag is removed from a Git endpoint, any packages already built for that tag remain.\n\nCommit mode is recommended when you only want users to have access to every individual update/commit made in a package, whereas tag mode is more suitable when you only want to expose stable releases of packages to users."
  },
  {
    "objectID": "pages/package-manager.html#package-manager-in-phs",
    "href": "pages/package-manager.html#package-manager-in-phs",
    "title": "PHS Package Development Guidance",
    "section": "Package Manager in PHS",
    "text": "Package Manager in PHS\nYou can check if the PHS POSIT Package Manager is using tags or commits for a particular package by searching the package name at https://ppm.publichealthscotland.org/client/#/repos/3/packages (the link can only be accessed when you are connected to the PHS network).\nIf we look at phsstyles on Package Manager, we can clearly see it is using commit mode (as of 27th June 2024) as the version number is long and looks auto-generated (0.1.1.0.0.0.1654859281)."
  },
  {
    "objectID": "pages/package-manager.html#advantages-and-disadvantages",
    "href": "pages/package-manager.html#advantages-and-disadvantages",
    "title": "PHS Package Development Guidance",
    "section": "Advantages and Disadvantages",
    "text": "Advantages and Disadvantages\nUsing commit mode on Package Manager to host an R package makes it easier for maintainers as they do not have to worry so much about how to version every update. The package maintainers would have to ensure (as far as possible) that only stable commits are made on the main branch. However, the disadvantage is that version history may be long (particularly if a number of small commits have been made) and storage space on the infrastructure used to host Package Manager is needed to store all source files. For example, phstemplates on Package Manager has a version created for every commit to the main branch:\nVERSION\n1.2.1.0.0.0.1719407970\n\nARCHIVED VERSIONS\n1.2.1.0.0.0.1718379552\nJun 14, 2024 3:39 PM UTC\n1.2.0.0.0.0.1707843561\nFeb 13, 2024 4:59 PM UTC\n1.1.1.0.0.0.1705940511\nJan 22, 2024 4:21 PM UTC\n1.1.1.0.0.0.1704882475\nJan 10, 2024 10:27 AM UTC\n1.1.1.0.0.0.1700760626\nNov 23, 2023 5:30 PM UTC\n1.1.1.0.0.0.1700647485\nNov 22, 2023 10:04 AM UTC\n1.1.1.0.0.0.1699616873\nNov 10, 2023 11:47 AM UTC\n1.1.1.0.0.0.1699351034\nNov 7, 2023 9:57 AM UTC\n1.1.1.0.0.0.1698952735\nNov 2, 2023 7:18 PM UTC\n1.1.1.0.0.0.1698157806\nOct 24, 2023 2:30 PM UTC\n1.1.1.0.0.0.1698053868\nOct 23, 2023 9:37 AM UTC\n1.1.1.0.0.0.1696581278\nOct 6, 2023 8:34 AM UTC\n1.1.1.0.0.0.1696322496\nOct 3, 2023 8:41 AM UTC\n1.1.1.0.0.0.1696251514\nOct 2, 2023 12:58 PM UTC\n1.1.0.0.0.0.1695820271\nSep 27, 2023 1:11 PM UTC\n1.1.0.0.0.0.1695805326\nSep 27, 2023 9:02 AM UTC\n1.1.0.0.0.0.1695735559\nSep 26, 2023 1:39 PM UTC\n1.1.0.0.0.0.1695658190\nSep 25, 2023 4:09 PM UTC\n1.1.0.0.0.0.1695206490\nSep 20, 2023 10:41 AM UTC\n1.1.0.0.0.0.1689262223\nJul 13, 2023 3:30 PM UTC\n1.1.0.0.0.0.1661965078\nAug 31, 2022 4:57 PM UTC\nAnother drawback with commit mode is that you would have to look at the commit history on Github to see exactly what changes were made for each of these versions. If a major bug was introduced at some point in the commit history, it could be challenging for a user to find and install the most recent stable version.\nTags mode requires more administrative work by maintainers of R packages (as an extra step is needed to associate commits with tags and to push these tags to Github) but should result in a cleaner version history on Package Manager. The deliberate tagging process should mean we get only a list of stable releases and changes in each version should have been clearly documented in news.md.\nIf Package Manager were to use tags mode for phstemplates, we would have only the latest v1.2.1 and three previous archived versions available, resulting in a lot fewer archived versions compared with commits mode.\n$ git tag\nv1.0.0\nv1.1.0\nv1.2.0\nv1.2.1\nThe benefit for users would be that it would be easier to install previous versions of a package if needed (for example, if the latest version introduced a bug). There should also be less versions created on Package Manager which would save some storage space on the infrastructure. Furthermore, these tags can be reviewed periodically and redundant versions can be deleted if desired."
  },
  {
    "objectID": "pages/package-manager.html#further-reading",
    "href": "pages/package-manager.html#further-reading",
    "title": "PHS Package Development Guidance",
    "section": "Further Reading",
    "text": "Further Reading\nBuilding Git Packages - Posit Package Manager"
  },
  {
    "objectID": "pages/recommended-git-workflow.html",
    "href": "pages/recommended-git-workflow.html",
    "title": "PHS Package Development Guidance",
    "section": "",
    "text": "Our recommended Git/Github developer workflow for versioning and tagging is as follows:\n\nCreate a development branch and switch to it, e.g.\ngit checkout -b feature/dev\nAdd your developments, commit and push these changes\ngit add -A\ngit commit -m \"my changes\"\ngit push origin feature/dev,\nSubmit a pull request on Github and get your changes reviewed\nOnce changes are approved, the maintainer decides on the major/minor/patch version increment (e.g. 1.3.0)\nThe developer updates to the agreed version in DESCRIPTION, e.g.\nusethis::use_version(1.3.0)\ngit add -A\ngit commit -m \"incrementing to v1.3.0\"\ngit push origin feature/dev\nThe pull request is merged to the main branch\nThe commit (let’s say the SHA is 1234567) is tagged with v1.3.0\ngit tag 1234567 v1.3.0\ngit push origin v1.3.0\n\nGraphically, this looks as follows:\n\n\n\n\nflowchart TB\n    mb([\"Main Branch\"])\n    cdb[\"Development Branch\"]\n    ca[\"Changes added\\nChanges committed\\nChanges pushed\"]\n    cr{Code Review}\n    vi[Version incremented]\n    ta[Tag latest commit]\n    mbu([Main Branch updated])\n\n    mb --\"git checkout -b feature/dev\" --&gt; cdb\n    cdb --\"git add -A\\ngit commit -m 'my changes'\\ngit push origin feature/dev\" --&gt; ca\n    ca --\"Github: Make Pull Request\"--&gt; cr\n    cr --\"Accept changes\\nusethis::use_version(1.3.0)\\ngit add -A\\ngit commit -m 'incrementing to v1.3.0'\\ngit push origin feature/dev\"--&gt; vi\n    vi -- \"Pull request merged to main\" --&gt; mbu\n    cr --\"Reject changes\"--&gt; cdb\n    ta &lt;-.\"git tag 1234567 v1.3.0\\ngit push origin v1.3.0\".-&gt; mbu\n\n    linkStyle default stroke:lightgray"
  },
  {
    "objectID": "pages/recommended-git-workflow.html#recommended-git-workflow",
    "href": "pages/recommended-git-workflow.html#recommended-git-workflow",
    "title": "PHS Package Development Guidance",
    "section": "",
    "text": "Our recommended Git/Github developer workflow for versioning and tagging is as follows:\n\nCreate a development branch and switch to it, e.g.\ngit checkout -b feature/dev\nAdd your developments, commit and push these changes\ngit add -A\ngit commit -m \"my changes\"\ngit push origin feature/dev,\nSubmit a pull request on Github and get your changes reviewed\nOnce changes are approved, the maintainer decides on the major/minor/patch version increment (e.g. 1.3.0)\nThe developer updates to the agreed version in DESCRIPTION, e.g.\nusethis::use_version(1.3.0)\ngit add -A\ngit commit -m \"incrementing to v1.3.0\"\ngit push origin feature/dev\nThe pull request is merged to the main branch\nThe commit (let’s say the SHA is 1234567) is tagged with v1.3.0\ngit tag 1234567 v1.3.0\ngit push origin v1.3.0\n\nGraphically, this looks as follows:\n\n\n\n\nflowchart TB\n    mb([\"Main Branch\"])\n    cdb[\"Development Branch\"]\n    ca[\"Changes added\\nChanges committed\\nChanges pushed\"]\n    cr{Code Review}\n    vi[Version incremented]\n    ta[Tag latest commit]\n    mbu([Main Branch updated])\n\n    mb --\"git checkout -b feature/dev\" --&gt; cdb\n    cdb --\"git add -A\\ngit commit -m 'my changes'\\ngit push origin feature/dev\" --&gt; ca\n    ca --\"Github: Make Pull Request\"--&gt; cr\n    cr --\"Accept changes\\nusethis::use_version(1.3.0)\\ngit add -A\\ngit commit -m 'incrementing to v1.3.0'\\ngit push origin feature/dev\"--&gt; vi\n    vi -- \"Pull request merged to main\" --&gt; mbu\n    cr --\"Reject changes\"--&gt; cdb\n    ta &lt;-.\"git tag 1234567 v1.3.0\\ngit push origin v1.3.0\".-&gt; mbu\n\n    linkStyle default stroke:lightgray"
  }
]